from pydantic import BaseModel, Field
from typing import List, Optional, Dict, Any
from abc import ABC
from dataclasses import dataclass
import tempfile
import asyncio
import os
from inspect import signature


class TaskOptions(BaseModel):
    files: Dict[str, object] = Field(
        default_factory=dict, description="Files to be used by the task")


class TaskResult(BaseModel):
    files: Dict[str, object] = Field(
        default_factory=dict, description="Files generated by the task")
    statistics: Dict[str, Any] = Field(
        default_factory=dict, description="Statistics generated by the task")


class Task(BaseModel):
    id: str
    type: str
    options: Optional[TaskOptions] = None
    
        

class TaskIOManager(ABC):
    async def mark_task_failed(self, task: Task, error: Exception):
        raise NotImplementedError()

    async def mark_task_completed(self, task: Task, result):
        raise NotImplementedError()

    async def download_bytes(self, task: Task, name: str, url: str) -> tuple[str, bytes]:
        raise NotImplementedError()

    async def upload_bytes(self, task: Task, name: str, filename: str, byte_array: bytes) -> tuple[str, str]:
        raise NotImplementedError()

    async def download_file(self, task: Task, name: str, url: str) -> tuple[str, str]:
        name, byte_array = await self.download_bytes(task, name, url)
        with tempfile.NamedTemporaryFile(delete=False, suffix=url.split('.')[-1]) as f:
            await asyncio.to_thread(f.write, byte_array)

        return name, f.name

    async def remove_file(self, task: Task, name: str, file_path: str):
        os.remove(file_path)

    async def upload_file(self, task: Task, name: str, file_path: str) -> tuple[str, str]:
        with open(file_path, 'rb') as f:
            byte_array = await asyncio.to_thread(f.read)
        return await self.upload_bytes(task, name, name + os.path.splitext(file_path)[-1], byte_array)


class TaskResourceResolver(object):
    async def encode_to_bytes(self, task: Task, name: str, resource: object) -> tuple[str, str, bytes]:
        raise NotImplementedError()

    async def decode_from_bytes(self, task: Task, name: str, byte_array: bytes) -> tuple[str, object]:
        raise NotImplementedError()

    async def download_files(self, task: Task, task_io_manager: TaskIOManager):
        assert isinstance(task_io_manager, TaskIOManager)
        assert isinstance(task, Task)

        files = task.options.files

        for name, url in files.copy().items():
            name, byte_array = await task_io_manager.download_bytes(task, name, url)
            name, obj = await self.decode_from_bytes(task, name, byte_array)
            files[name] = obj

    async def upload_files(self, task: Task, task_io_manager: TaskIOManager):
        assert isinstance(task_io_manager, TaskIOManager)
        assert isinstance(task, Task)
        
        files = task.result.files

        for name, obj in files.copy().items():
            name, byte_array = await self.encode_to_bytes(name, obj)
            name, url = await task_io_manager.upload_bytes(task, name, name, byte_array)
            files[name] = url


class RestartRequest(SystemExit):
    def __init__(self, exception: Exception, code: int=1):
        super().__init__(code)
        self.exception = exception


class TaskExectionInfo(object):
    """
    The function will some subclass of TaskOptions and return some subclass of TaskResult
    The execptions thrown by the function will be reported to the server
    The function can raise RestartRequest to restart the server
    Before the function is called, the files will be prcessed by the resource_resolver
    """
    def __init__(self, type_name: str,
                 func,
                 resource_resolver: TaskResourceResolver,
                 options_type: type = None,
                 result_type: type = None,
                 documantation: str = None):
        self.type_name = type_name
        self.func = func
        self.resource_resolver = resource_resolver
        self.options_type = options_type
        self.result_type = result_type
        self.documantation = documantation


        if not callable(func):
            raise TypeError(f"Task function must be callable instead of {func}")

        if self.result_type is None:
            self.result_type = signature(func).return_annotation

        if not (issubclass(self.result_type, TaskResult) or self.result_type == TaskResult):
            raise TypeError(f"Task result type must be a subclass of TaskResult instead of {self.result_type}")

        if len(signature(func).parameters) != 1:
            raise TypeError("Task function must have exactly one parameter")

        if self.options_type is None:
            self.options_type = next(iter(signature(func).parameters.values())).annotation

        if not (issubclass(self.options_type, TaskOptions) or self.options_type == TaskOptions):
            raise TypeError(f"Task options type must be a subclass of TaskOptions instead of {self.options_type}")
        
        if not isinstance(self.resource_resolver, TaskResourceResolver):
            raise TypeError(f"Task resource_resolver must be a instance of TaskResourceResolver instead of {self.resource_resolver}")

        if self.documantation is None:
            if func.__doc__ is None:
                self.documantation = f'No documentation for {func.__name__}'
            else:
                self.documantation = func.__doc__

        
@dataclass
class TaskInfo(object):
    task: Task
    execution_info: TaskExectionInfo
    task_io_manager: TaskIOManager

    @property
    def resource_resolver(self):
        return self.execution_info.resource_resolver


class TaskSource(ABC):
    def __init__(self, supported_tasks: List[TaskExectionInfo], **kwargs) -> None:
        self.supported_tasks = supported_tasks

    async def fetch_task(self) -> Optional[TaskInfo]:
        raise NotImplementedError()

    def build_api_router(self):
        """
        Build a FastAPI router for this task source
        """
        return None
